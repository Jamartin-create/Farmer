from utils import get_x_y
import map_manage
from consts import FERTILIZER_MIN_STOCK, CARROT_LOW_WATERMARK, SUNFLOWER_MIN_COUNT_FOR_8X, FERTILIZER_USE_THRESHOLD

# -----------------------------------------------------------------------------
# 南瓜合并区状态（用于“全区成熟后再收割”的判定）
pumpkin_ready_map = None          # 2D bool：记录南瓜区每格是否“成熟且是 Pumpkin”
pumpkin_ready_to_harvest = False  # bool：检测到全区成熟后置 True，直到成功收一次（巨型南瓜）
pumpkin_ready_m = None            # 当前 m，用于判断是否需要重建缓存

# -----------------------------------------------------------------------------
# 向日葵状态（用于 8 倍能量：只收“当前最大花瓣数”的那株）
sunflower_petals_map = None  # 2D number：记录每格向日葵花瓣数（非向日葵为 0）
sunflower_memo_n = None      # 当前世界大小 n，用于判断是否需要重建缓存

# -----------------------------------------------------------------------------
# 混合种植 / 伴生植物（Companion）需求缓存
# 机制：草/灌木/树/胡萝卜在有"伴生植物"时产量更高；get_companion() 可读出需求。
companion_need_map = None  # 2D Entity|None：记录某格被请求种的伴生植物类型
companion_memo_n = None

# -----------------------------------------------------------------------------
# 迷宫状态（用于生成、导航和收获）
maze_generated = False        # bool：是否已生成迷宫
maze_size = None              # int：当前迷宫大小（n×n）
maze_substance_needed = None  # int：生成迷宫所需的 Weird_Substance 数量
maze_visited = None           # 2D bool：DFS 导航时的访问标记
maze_path = None              # list：DFS 导航路径栈
maze_navigating = False       # bool：是否正在导航到宝藏
maze_nav_direction = None     # Direction|None：导航建议的移动方向
maze_memo_n = None            # int：当前世界大小 n，用于判断是否需要重建缓存
is_in_maze = False             # bool：当前是否在迷宫中（用于切换运动模式）

def _floor_half(n):
	# 计算 floor(n/2)，避免依赖 “//” 或 int() 在脚本解释器中的兼容性
	half = 0
	while (half + 1) * 2 <= n:
		half = half + 1
	return half


def _pumpkin_merge_size(n):
	# 动态合并区边长：m = n - floor(n/2)
	return n - _floor_half(n)


def _in_pumpkin_zone(x, y, m):
	# 合并区固定左上角：0<=x<m 且 0<=y<m
	return x >= 0 and y >= 0 and x < m and y < m


def _init_pumpkin_ready_state(n, m):
	# 初始化/重建南瓜区成熟度缓存
	global pumpkin_ready_map
	global pumpkin_ready_to_harvest
	global pumpkin_ready_m

	pumpkin_ready_m = m
	pumpkin_ready_to_harvest = False

	pumpkin_ready_map = []
	for _ in range(n):
		row = []
		for _ in range(n):
			row.append(False)
		pumpkin_ready_map.append(row)


def _set_pumpkin_ready(x, y, is_ready):
	# 更新单格成熟度（仅对南瓜区内格子调用）
	if pumpkin_ready_map == None:
		return
	pumpkin_ready_map[x][y] = is_ready


def _pumpkin_zone_all_ready(m):
	# 判断 m×m 南瓜区是否全部“成熟且是 Pumpkin”
	if pumpkin_ready_map == None:
		return False
	for x in range(m):
		for y in range(m):
			if pumpkin_ready_map[x][y] != True:
				return False
	return True


def _clear_pumpkin_zone_ready(m):
	# 收割巨型南瓜后清空缓存，进入下一轮
	if pumpkin_ready_map == None:
		return
	for x in range(m):
		for y in range(m):
			pumpkin_ready_map[x][y] = False


def _in_cactus_zone(x, y, m, n):
	# 仙人掌区：位于南瓜区右侧，与南瓜区相邻
	# 区域：m+1 <= x < min(2*m+1, n) 且 0 <= y < m
	# 注意：供给环带优先级更高（x == m 或 y == m），会先处理，因此仙人掌区从 m+1 开始
	max_x = 2 * m + 1
	if max_x > n:
		max_x = n
	return x >= (m + 1) and x < max_x and y >= 0 and y < m


def _in_support_ring(x, y, m):
	# 南瓜区外侧的"供给环带"：用于胡萝卜等资源供给
	# 说明：胡萝卜产能容易过剩，因此这里将供给区收缩为"贴着南瓜区外沿的一圈（厚度 1 格）"
	# - 右侧竖边：y < m 且 x == m
	# - 下侧横边：x < m 且 y == m
	# 例：n=6,m=3 时，胡萝卜区为 6 格，而不是 18 格。
	return (y < m and x == m) or (x < m and y == m)


def _is_tree_spot(x, y, m):
	# 树点位：在南瓜区外（本函数只会在南瓜区外调用）采用“全图棋盘格”
	# 用棋盘格 + “邻居有树则改种草”来降低相邻树带来的生长减速
	return (x + y) % 2 == 0


def _is_sunflower_spot(x, y, m):
	# 向日葵点位：使用棋盘格的"另一半"（不占用树点位），保证同时存在树与向日葵
	# 本函数只会在南瓜区外调用；胡萝卜供给圈优先级更高，会先 return
	return (x + y) % 2 == 1


def _in_maze_zone(x, y, m, n):
	# 迷宫区：位于右下角，避免与其他区域冲突
	# 区域：右下角 n/2 × n/2 的区域（如果 n 为奇数，则向下取整）
	# 具体：x >= n - floor(n/2) 且 y >= n - floor(n/2)
	maze_start = n - _floor_half(n)
	return x >= maze_start and y >= maze_start


def _ensure_soil():
	# 耕地是开关：只在草地时 till 一次，避免 Soil -> Grassland 的反切换
	if get_ground_type() == Grounds.Grassland:
		till()


def _plant_pumpkin_here():
	_ensure_soil()
	plant(Entities.Pumpkin)


def _plant_carrot_here():
	_ensure_soil()
	plant(Entities.Carrot)


def _plant_grass_here():
	# 草可种在草地或土壤上；一般只在空地时补种即可
	plant(Entities.Grass)


def _plant_tree_here():
	# 树可种在草地或土壤上，不需要耕地
	plant(Entities.Tree)


def _plant_sunflower_here():
	_ensure_soil()
	plant(Entities.Sunflower)

def _plant_cactus_here():
	# 仙人掌需要种植在耕过的土地上
	_ensure_soil()
	plant(Entities.Cactus)

def _plant_bush_here():
	# 灌木可种在草地或土壤上，不需要耕地
	plant(Entities.Bush)


def _generate_maze_if_needed():
	# 检查是否已有迷宫，如果没有则尝试生成
	global maze_generated
	global maze_size
	global maze_substance_needed
	
	entity = get_entity_type()
	
	# 如果已经在迷宫中（Hedge 或 Treasure），标记为已生成
	if entity == Entities.Hedge or entity == Entities.Treasure:
		if not maze_generated:
			maze_generated = True
			n = get_world_size()
			maze_size = n
			maze_substance_needed = n * 2**(num_unlocked(Unlocks.Mazes) - 1)
		return True
	
	# 如果已经生成过，但当前位置不在迷宫中，可能是走出了迷宫或迷宫被清除
	# 这种情况下，如果资源充足，可以重新生成
	if maze_generated:
		return True
	
	# 计算所需资源
	n = get_world_size()
	substance_needed = n * 2**(num_unlocked(Unlocks.Mazes) - 1)
	
	# 检查资源是否充足
	if num_items(Items.Weird_Substance) < substance_needed:
		return False
	
	# 确保当前位置是灌木
	if entity != Entities.Bush:
		_plant_bush_here()
		return False  # 需要等待灌木生成
	
	# 生成迷宫
	use_item(Items.Weird_Substance, substance_needed)
	maze_generated = True
	maze_size = n
	maze_substance_needed = substance_needed
	return True


def _reset_maze_navigation():
	# 重置导航状态
	global maze_navigating
	global maze_path
	global maze_visited
	global maze_nav_direction
	
	maze_navigating = False
	maze_path = []
	maze_nav_direction = None
	
	n = maze_memo_n
	if maze_visited == None:
		return
	for x in range(n):
		for y in range(n):
			maze_visited[x][y] = False


# 迷宫导航状态：返回建议的移动方向（None 表示不需要移动或已完成）
maze_nav_direction = None

def _navigate_to_treasure():
	# 使用 DFS 导航到宝藏
	# 返回建议的移动方向（North/South/East/West），或 None（如果不需要移动）
	# 注意：这个函数只计算方向，不执行移动，移动由 do_move.py 处理
	global maze_navigating
	global maze_path
	global maze_visited
	global maze_nav_direction
	
	# 获取宝藏位置
	treasure_pos = measure()
	if treasure_pos == None:
		maze_nav_direction = None
		return None
	
	treasure_x, treasure_y = treasure_pos
	[current_x, current_y] = get_x_y()
	
	# 如果已经在宝藏位置
	if current_x == treasure_x and current_y == treasure_y:
		_reset_maze_navigation()
		maze_nav_direction = None
		return None
	
	# 初始化导航状态
	if not maze_navigating:
		maze_navigating = True
		maze_path = [[current_x, current_y]]
		n = maze_memo_n
		if maze_visited == None:
			_init_maze_state(n)
		for x in range(n):
			for y in range(n):
				maze_visited[x][y] = False
		maze_visited[current_x][current_y] = True
	
	# DFS 单步：尝试向未访问的相邻格子移动
	directions = [North, South, East, West]
	
	for direction in directions:
		if not can_move(direction):
			continue
		
		# 计算目标位置
		if direction == North:
			next_x, next_y = current_x, current_y + 1
		elif direction == South:
			next_x, next_y = current_x, current_y - 1
		elif direction == East:
			next_x, next_y = current_x + 1, current_y
		else:  # West
			next_x, next_y = current_x - 1, current_y
		
		# 边界检查
		n = maze_memo_n
		if next_x < 0 or next_x >= n or next_y < 0 or next_y >= n:
			continue
		
		# 如果已访问，跳过
		if maze_visited[next_x][next_y]:
			continue
		
		# 找到未访问的相邻格子，建议移动
		maze_path.append([next_x, next_y])
		maze_visited[next_x][next_y] = True
		maze_nav_direction = direction
		return direction
	
	# 所有方向都不可行，需要回溯到上一个节点
	# 当前位置是死胡同，保持已访问状态（避免重复访问）
	# 但需要回溯到路径中的上一个节点继续搜索
	if len(maze_path) > 1:
		# 从路径中移除当前位置（回溯）
		maze_path.pop()
		# 获取上一个节点位置
		prev_pos = maze_path[-1]
		prev_x, prev_y = prev_pos[0], prev_pos[1]
		
		# 计算需要移动的方向（返回到上一个节点）
		# 在迷宫中，相邻节点之间的坐标差应该是 ±1
		dx = prev_x - current_x
		dy = prev_y - current_y
		
		# 根据坐标差确定移动方向
		if dx == 1:
			maze_nav_direction = East
			return East
		elif dx == -1:
			maze_nav_direction = West
			return West
		elif dy == 1:
			maze_nav_direction = North
			return North
		elif dy == -1:
			maze_nav_direction = South
			return South
		else:
			# 坐标差不是 ±1，说明路径栈可能有问题
			# 重置导航状态，重新开始
			_reset_maze_navigation()
			maze_nav_direction = None
			return None
	
	# 路径栈为空，无法回溯（理论上不应该发生，因为至少应该有起始点）
	# 重置导航状态
	_reset_maze_navigation()
	maze_nav_direction = None
	return None


def get_maze_nav_direction():
	# 获取迷宫导航建议的移动方向
	# 返回 None 如果不在迷宫中或不需要导航
	global maze_nav_direction
	return maze_nav_direction


def _check_and_update_maze_status():
	# 检查当前位置是否在迷宫中，并更新 is_in_maze 状态
	global is_in_maze
	entity = get_entity_type()
	
	# 如果在迷宫中（Hedge 或 Treasure）
	if entity == Entities.Hedge or entity == Entities.Treasure:
		if not is_in_maze:
			is_in_maze = True
		return True
	
	# 如果不在迷宫中
	if is_in_maze:
		is_in_maze = False
		# 离开迷宫时重置导航状态
		_reset_maze_navigation()
	
	return False


def is_in_maze_mode():
	# 获取当前是否在迷宫模式（供 do_move.py 使用）
	global is_in_maze
	return is_in_maze


def _replant_as(target_entity):
	# 统一的"收获后补种"入口：不同作物遵守不同规则
	if target_entity == Entities.Carrot:
		_plant_carrot_here()
		# 肥料应在“种植之后”立刻使用，否则绕一圈回来往往已经成熟，错过加速窗口
		_maybe_use_fertilizer(Entities.Carrot)
		return
	if target_entity == Entities.Pumpkin:
		_plant_pumpkin_here()
		return
	if target_entity == Entities.Sunflower:
		_plant_sunflower_here()
		return
	if target_entity == Entities.Cactus:
		_plant_cactus_here()
		# 同上：仙人掌也在种下后立刻考虑施肥
		_maybe_use_fertilizer(Entities.Cactus)
		return
	if target_entity == Entities.Tree:
		_plant_tree_here()
		return
	if target_entity == Entities.Bush:
		_plant_bush_here()
		return
	if target_entity == Entities.Grass:
		_plant_grass_here()
		return


def _handle_generic_cell(target_entity):
	# 通用处理：能收就收，能补就补；不可收且非空则先不动
	entity = get_entity_type()

	# 枯萎南瓜：可被新种植直接覆盖
	if entity == Entities.Dead_Pumpkin:
		_replant_as(target_entity)
		return

	# 空地：直接补种目标
	if entity == None:
		_replant_as(target_entity)
		return

	# 目标已在地里：按目标作物规则处理
	if entity == target_entity:
		if can_harvest():
			harvest()
			_replant_as(target_entity)
		return

	# 其他作物：如果可收则收掉再换种；不可收则暂时保留
	if can_harvest():
		harvest()
		_replant_as(target_entity)


def _maybe_use_fertilizer(target_entity):
	# 肥料会感染植物，收获时一半产量会变成 Weird_Substance。
	# 你希望“肥料别囤着”：因此这里改为更积极使用。
	#
	# 原则：
	# - 只对“可接受感染”的作物使用（这里选 Carrot / Cactus），避免污染向日葵（会影响能量产出）
	# - 只在目标作物“未成熟”时施肥（才能减少剩余生长时间）
	# - 肥料库存很低时保守点（避免关键时刻没肥料）

	if target_entity != Entities.Carrot and target_entity != Entities.Cactus:
		return

	if get_entity_type() != target_entity:
		return
	if can_harvest():
		return

	f = num_items(Items.Fertilizer)
	if f < FERTILIZER_MIN_STOCK:
		return

	# 两种触发路径：
	# - 胡萝卜库存偏低：仍然保证补给
	# - 或者肥料库存偏高：主动消耗以获取 Weird_Substance
	if target_entity == Entities.Carrot:
		if num_items(Items.Carrot) < CARROT_LOW_WATERMARK or f >= FERTILIZER_USE_THRESHOLD:
			use_item(Items.Fertilizer)
		return

	# Cactus：作为“可接受感染”的产出区，肥料多时更积极用
	if f >= FERTILIZER_USE_THRESHOLD:
		use_item(Items.Fertilizer)


def _init_sunflower_state(n):
	global sunflower_petals_map
	global sunflower_memo_n
	sunflower_memo_n = n
	sunflower_petals_map = []
	for _ in range(n):
		row = []
		for _ in range(n):
			row.append(0)
		sunflower_petals_map.append(row)


def _init_companion_state(n):
	global companion_need_map
	global companion_memo_n
	companion_memo_n = n
	companion_need_map = []
	for _ in range(n):
		row = []
		for _ in range(n):
			row.append(None)
		companion_need_map.append(row)


def _init_maze_state(n):
	# 初始化/重建迷宫状态缓存
	global maze_generated
	global maze_size
	global maze_substance_needed
	global maze_visited
	global maze_path
	global maze_navigating
	global maze_memo_n
	
	maze_memo_n = n
	maze_generated = False
	maze_size = None
	maze_substance_needed = None
	maze_navigating = False
	
	maze_visited = []
	for _ in range(n):
		row = []
		for _ in range(n):
			row.append(False)
		maze_visited.append(row)
	
	maze_path = []


def _companion_priority(entity):
	# 解决“同一目标格子被多个植物请求”的冲突：优先保证更高价值产出
	# 你可以按自己资源短缺情况调整优先级。
	if entity == Entities.Tree:
		return 40
	if entity == Entities.Bush:
		return 30
	if entity == Entities.Carrot:
		return 20
	if entity == Entities.Grass:
		return 10
	return 0


def _maybe_record_companion_need(x, y, m):
	# 只在南瓜区外记录伴生需求；南瓜不参与伴生系统
	if companion_need_map == None:
		return

	entity = get_entity_type()
	if entity != Entities.Grass and entity != Entities.Bush and entity != Entities.Tree and entity != Entities.Carrot:
		return

	companion = get_companion()
	if companion == None:
		return

	plant_type, (tx, ty) = companion
	n = companion_memo_n

	# 目标坐标有可能由于“越界折返”效果而表现得像在另一侧；
	# 这里做一次朴素的归一化，确保索引安全。
	while tx < 0:
		tx = tx + n
	while ty < 0:
		ty = ty + n
	while tx >= n:
		tx = tx - n
	while ty >= n:
		ty = ty - n

	# 目标落在南瓜区：忽略，避免破坏南瓜合并
	if _in_pumpkin_zone(tx, ty, m):
		return

	current = companion_need_map[tx][ty]
	if current == None or _companion_priority(plant_type) > _companion_priority(current):
		companion_need_map[tx][ty] = plant_type


def _handle_companion_need_tile(x, y):
	# 如果当前格子被标记为“伴生需求点位”，则优先满足需求
	if companion_need_map == None:
		return False

	need = companion_need_map[x][y]
	if need == None:
		return False

	_handle_generic_cell(need)
	# 需求已处理：清空，避免长期占用该格导致默认分区无法回补
	# （后续若再次被请求，会重新写入）
	companion_need_map[x][y] = None
	return True


def _update_sunflower_petals_at_current_pos():
	# 若当前位置是向日葵，则记录其花瓣数；否则清零
	if sunflower_petals_map == None:
		return
	[x, y] = get_x_y()
	if get_entity_type() == Entities.Sunflower:
		p = measure()
		sunflower_petals_map[x][y] = p
	else:
		sunflower_petals_map[x][y] = 0


def _sunflower_count_and_max_petals():
	# 统计当前缓存中的向日葵数量与最大花瓣数
	if sunflower_petals_map == None:
		return [0, 0]
	n = sunflower_memo_n
	count = 0
	max_p = 0
	for x in range(n):
		for y in range(n):
			p = sunflower_petals_map[x][y]
			if p > 0:
				count = count + 1
				if p > max_p:
					max_p = p
	return [count, max_p]


def _handle_sunflower_cell():
	# 向日葵策略：
	# - 先 measure 缓存花瓣数（未成熟也可测）
	# - 数量不足 10：先攒数量，不急着收
	# - 数量 >= 10：只收“当前最大花瓣数”的成熟向日葵，确保 8 倍能量规则成立
	entity = get_entity_type()

	# 枯萎南瓜可被新种植覆盖
	if entity == Entities.Dead_Pumpkin:
		_plant_sunflower_here()
		return

	# 空地：补种向日葵
	if entity == None:
		_plant_sunflower_here()
		_update_sunflower_petals_at_current_pos()
		return

	# 是向日葵：更新花瓣缓存后决定是否收割
	if entity == Entities.Sunflower:
		_update_sunflower_petals_at_current_pos()
		[count, max_p] = _sunflower_count_and_max_petals()

		# 先攒到 10 株再追求 8 倍（避免边收边掉到 10 以下）
		if count < SUNFLOWER_MIN_COUNT_FOR_8X:
			return

		# 只收最大花瓣（允许并列最大）
		if can_harvest():
			[x, y] = get_x_y()
			if sunflower_petals_map[x][y] == max_p:
				harvest()
				_plant_sunflower_here()
				_update_sunflower_petals_at_current_pos()
		return

	# 其他作物：可收则收掉再换种；不可收则先不动
	if can_harvest():
		harvest()
		_plant_sunflower_here()
		_update_sunflower_petals_at_current_pos()


def _handle_pumpkin_zone_cell():
	# 南瓜合并区维护规则（按 docs/pumpkin_strategy.md）：
	# - Dead_Pumpkin：直接补种 Pumpkin（自动移除枯萎）
	# - 空地：补种 Pumpkin
	# - 普通成熟 Pumpkin：不收，等待合并
	# - 当检测到“全区都成熟”后：才 harvest（等同于收巨型南瓜）
	entity = get_entity_type()
	[x, y] = get_x_y()
	m = pumpkin_ready_m

	# 枯萎南瓜：can_harvest() 永远 False，直接补种覆盖
	if entity == Entities.Dead_Pumpkin:
		_set_pumpkin_ready(x, y, False)
		_plant_pumpkin_here()
		return

	# 空地：补种
	if entity == None:
		_set_pumpkin_ready(x, y, False)
		_plant_pumpkin_here()
		return

	# 南瓜：更新成熟度；只有在“全区都成熟”之后，才允许收割（收巨型南瓜）
	if entity == Entities.Pumpkin:
		if can_harvest():
			_set_pumpkin_ready(x, y, True)
		else:
			_set_pumpkin_ready(x, y, False)

		# 检测到“全区成熟”，置收割标记（持续到收割成功一次）
		global pumpkin_ready_to_harvest
		if (pumpkin_ready_to_harvest == False) and _pumpkin_zone_all_ready(m):
			pumpkin_ready_to_harvest = True

		if pumpkin_ready_to_harvest and can_harvest():
			harvest()
			pumpkin_ready_to_harvest = False
			_clear_pumpkin_zone_ready(m)
			# 收割后立刻补种，启动下一轮
			_plant_pumpkin_here()
		return

	# 其他异常实体：尽量把合并区恢复为南瓜
	if can_harvest():
		harvest()
	_set_pumpkin_ready(x, y, False)
	_plant_pumpkin_here()


def _handle_cactus_zone_cell():
	# 仙人掌区维护规则（按 docs/cactus_strategy.md）：
	# - 空地：补种 Cactus
	# - 成熟 Cactus：能收就收（连锁收集由游戏自动处理）
	# - 其他作物：可收则收掉再换种；不可收则暂时保留
	entity = get_entity_type()

	# 枯萎南瓜可被新种植覆盖
	if entity == Entities.Dead_Pumpkin:
		_replant_as(Entities.Cactus)
		return

	# 空地：补种仙人掌
	if entity == None:
		_replant_as(Entities.Cactus)
		return

	# 是仙人掌：能收就收，收完补种
	if entity == Entities.Cactus:
		if can_harvest():
			harvest()
			_replant_as(Entities.Cactus)
		return

	# 其他作物：可收则收掉再换种；不可收则先不动
	if can_harvest():
		harvest()
		_replant_as(Entities.Cactus)


def _handle_maze_zone_cell():
	# 迷宫区维护规则（按 docs/maze_strategy.md）：
	# - 如果还没有生成迷宫，尝试生成（需要足够的 Weird_Substance）
	# - 如果在宝藏位置，收获宝藏
	# - 如果在迷宫中但不是宝藏，导航到宝藏
	# - 重要：在非宝藏位置使用 harvest() 会导致迷宫消失，必须避免
	global maze_generated
	
	# 检查并更新迷宫状态（用于切换运动模式）
	_check_and_update_maze_status()
	
	entity = get_entity_type()
	
	# 如果还没有生成迷宫，尝试生成
	if entity != Entities.Hedge and entity != Entities.Treasure:
		if not _generate_maze_if_needed():
			# 资源不足，等待
			return
	
	# 如果在宝藏位置，收获
	if entity == Entities.Treasure:
		harvest()
		# 收获后重置状态，下次可以重新生成
		maze_generated = False
		_reset_maze_navigation()
		# 更新状态：收获后离开迷宫
		_check_and_update_maze_status()
		return
	
	# 如果在迷宫中但不是宝藏，计算导航方向
	if entity == Entities.Hedge:
		_navigate_to_treasure()
		return
	
	# 其他情况（理论上不应该发生）：尝试生成迷宫
	_generate_maze_if_needed()


def _handle_support_cell(x, y, m, n):
	# 南瓜区外：多作物分区（胡萝卜供给 + 仙人掌 + 树木 + 草 + 迷宫）
	#
	# 规则：
	# - 环带：胡萝卜（支撑南瓜补种消耗）
	# - 仙人掌区：南瓜区右侧（m <= x < min(2*m, n), 0 <= y < m）
	# - 迷宫区：右下角（x >= n - floor(n/2) 且 y >= n - floor(n/2)）
	# - 棋盘格：树（尽量避免相邻树减速）
	# - 其他：草（干草来源/兜底）
	#
	# 另外：如果命中"伴生需求点位"，则优先满足伴生需求（提高草/灌木/树/胡萝卜的收获产量）。

	# 先记录当前位置植物的伴生需求（只对草/灌木/树/胡萝卜有效）
	_maybe_record_companion_need(x, y, m)

	# 若当前格子是伴生需求点位，则覆盖默认分区逻辑
	if _handle_companion_need_tile(x, y):
		return

	# 迷宫区优先级最高（避免与其他区域冲突）
	if _in_maze_zone(x, y, m, n):
		_handle_maze_zone_cell()
		return

	if _in_support_ring(x, y, m):
		# 胡萝卜供给区：肥料在"补种之后"由 _replant_as() 立刻触发（更有效）
		_handle_generic_cell(Entities.Carrot)
		return

	if _in_cactus_zone(x, y, m, n):
		# 仙人掌区：优先处理仙人掌
		_handle_cactus_zone_cell()
		return

	if _is_sunflower_spot(x, y, m):
		_handle_sunflower_cell()
		return

	if _is_tree_spot(x, y, m):
		# 若已知邻居有树，则此格改种草，进一步降低相邻概率
		if map_manage.check_neighbor_has(Entities.Tree):
			_handle_generic_cell(Entities.Grass)
		else:
			_handle_generic_cell(Entities.Tree)
		return

	_handle_generic_cell(Entities.Grass)


def plant_something():
	# 每个格子的主要逻辑：
	# - 左上角 m×m：南瓜合并区（只收"合并后孤立南瓜"）
	# - 其他：多作物分区（见 docs）
	[x, y] = get_x_y()

	# 检查并更新迷宫状态（用于切换运动模式）
	# 注意：这个检查需要在所有逻辑之前，确保状态及时更新
	_check_and_update_maze_status()

	n = get_world_size()
	m = _pumpkin_merge_size(n)

	# 初始化伴生需求缓存（n 变化则重建）
	global companion_need_map
	global companion_memo_n
	if companion_need_map == None or companion_memo_n != n:
		_init_companion_state(n)

	# 初始化向日葵花瓣缓存（n 变化则重建）
	global sunflower_petals_map
	global sunflower_memo_n
	if sunflower_petals_map == None or sunflower_memo_n != n:
		_init_sunflower_state(n)

	# 初始化南瓜成熟度缓存（只要 m 改变就重建）
	global pumpkin_ready_map
	global pumpkin_ready_m
	if pumpkin_ready_map == None or pumpkin_ready_m != m:
		_init_pumpkin_ready_state(n, m)

	# 初始化迷宫状态缓存（n 变化则重建）
	global maze_visited
	global maze_memo_n
	if maze_visited == None or maze_memo_n != n:
		_init_maze_state(n)

	if _in_pumpkin_zone(x, y, m):
		_handle_pumpkin_zone_cell()
	else:
		_handle_support_cell(x, y, m, n)
		
